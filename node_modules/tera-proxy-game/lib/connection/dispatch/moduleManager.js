"use strict";
const fs = require('fs');
const path = require('path');
const Module = require('./module');
const DiscordURL = "https://discord.gg/dUNDDtw";

function listModules(rootFolder) {
    let names = [];

    for (let name of fs.readdirSync(rootFolder)) {
        if (name[0] === "." || name[0] === "_")
            continue;
        if (!name.endsWith(".js") && !fs.lstatSync(path.join(rootFolder, name)).isDirectory())
            continue;

        names.push(name);
    }

    return names;
}

function loadModuleInfo(rootFolder, name) {
    const modulePath = path.join(rootFolder, name);

    let result = {
        'name': name,
        'path': modulePath,
        'author': null,
        'description': null,
        'version': null,
        'donationUrl': null,
        'options': {},
        'drmKey': null,
        'supportUrl': null,
        'autoUpdateDisabled': null,
        'packets': {},
    };

    const standalone = !fs.lstatSync(modulePath).isDirectory();
    if (standalone) {
        if (!name.endsWith(".js"))
            throw new Error(`Invalid mod ${name}`);

        // Standalone legacy mod
        Object.assign(result, {
            'type': 'standalone',
            'compatibility': 'legacy',
        });
    } else {
        // Try to load module information and manifest files
        let moduleInfo = null;
        try {
            moduleInfo = fs.readFileSync(path.join(modulePath, 'module.json'), 'utf8');
        } catch (_) {
            // Files not found, so regular legacy mod
            Object.assign(result, {
                'type': 'regular',
                'compatibility': 'legacy',
            });
        }

        // Parse and load module information
        if (moduleInfo) {
            moduleInfo = JSON.parse(moduleInfo);

            Object.assign(result, {
                'type': 'regular',
                'compatibility': 'compatible',
                'name': moduleInfo.name || result.name,
                'author': moduleInfo.author || result.author,
                'description': moduleInfo.description || result.description,
                'version': moduleInfo.version || result.version,
                'donationUrl': moduleInfo.donationUrl || result.donationUrl,
                'options': moduleInfo.options || result.options,
                'drmKey': moduleInfo.drmKey || result.drmKey,
                'supportUrl': moduleInfo.supportUrl || result.supportUrl,
                'autoUpdateDisabled': !!moduleInfo.disableAutoUpdate,
            });

            // Try to load required defs from manifest
            let moduleManifest = null;
            try {
                moduleManifest = fs.readFileSync(path.join(modulePath, 'manifest.json'), 'utf8');
            } catch (_) {
                // Ignore
            }

            if (moduleManifest) {
                moduleManifest = JSON.parse(moduleManifest);
                result.packets = moduleManifest.defs || result.packets;
            }
        }
    }

    // Post-process data
    if (!result.options.loadOn)
        result.options.loadOn = 'versioncheck';
    return result;
}

class ModuleManager {
    constructor(dispatch, rootFolder) {
        this.dispatch = dispatch;
        this.rootFolder = rootFolder;
        this.installedModules = new Map();
        this.loadedModules = new Map();

        this.dispatch.on('init', () => this._loadAll('versioncheck'));
    }

    destructor() {
        this.unloadAll();
        this.dispatch = null;
    }

    isInstalled(name) {
        return this.installedModules.has(name);
    }

    getInfo(name) {
        return this.installedModules.get(name);
    }

    isLoaded(name) {
        return this.loadedModules.has(name);
    }

    get(name) {
        return this.loadedModules.get(name);
    }

    isCoreModule(name) {
        return ['command', 'tera-game-state'].includes(name);
    }

    _loadAll(loadOn) {
        // Load core modules first
        this.installedModules.forEach(mod => {
            if (this.isCoreModule(mod.name) && !this.isLoaded(mod.name) && mod.options.loadOn === loadOn)
                this.load(mod.name, mod.options);
        });

        // Then load other modules
        this.installedModules.forEach(mod => {
            if (!this.isCoreModule(mod.name) && !this.isLoaded(mod.name) && mod.options.loadOn === loadOn)
                this.load(mod.name, mod.options);
        });
    }

    loadAll() {
        // List modules
        this.installedModules.clear();
        for (let name of fs.readdirSync(this.rootFolder)) {
            // Filter
            if (name[0] === "." || name[0] === "_")
                continue;
            if (!name.endsWith(".js") && !fs.lstatSync(path.join(this.rootFolder, name)).isDirectory())
                continue;

            // Load module info
            let moduleInfo;
            try {
                moduleInfo = loadModuleInfo(this.rootFolder, name);
            } catch (e) {
                console.error(`[mods] ERROR: Unable to load module information for "${name}"`);
                console.error(e);
            }

            // Validate module info
            if (this.installedModules.has(moduleInfo.name)) {
                console.error(`[mods] ERROR: Duplicate module "${name}" detected!`);
            } else {
                const missingDefs = this.dispatch.checkDefinitions(moduleInfo.packets);
                if (missingDefs.length > 0) {
                    console.error(`[mods] ERROR: Module "${name}" uses the following outdated packets:`);
                    missingDefs.forEach(def => console.error(`[mods] ERROR: - ${def.name}.${def.version}`));
                    console.error(`[mods] ERROR: Please contact the module's author: ${moduleInfo.supportUrl || DiscordURL}`);
                } else {
                    this.installedModules.set(moduleInfo.name, moduleInfo);
                }
            }
        }

        // Load all modules that are loaded immediately
        this._loadAll('connect');
    }

    unloadAll() {
        this.loadedModules.forEach(mod => this.unload(mod.name));
    }

    load(name, logInfo = true) {
        let module = this.get(name);
        if (module)
            return module;

        const moduleInfo = this.getInfo(name);
        if (!moduleInfo) {
            console.error(`[mods] ERROR: Trying to load module that is not installed: ${name}`);
        } else {
            try {
                module = new Module(this, moduleInfo);
                const moduleConstructor = require(moduleInfo.path);
                module.instance = new moduleConstructor(module);
                this.loadedModules.set(moduleInfo.name, module);

                if (logInfo)
                    console.log(`[mods] Loaded module "${moduleInfo.name}"`);
            } catch (e) {
                // Remove any hooks that may have been added by the broken module
                this.dispatch.unhookModule(moduleInfo.name);

                // Clear module files from require cache
                Object.keys(require.cache).forEach(key => {
                    if (key.startsWith(moduleInfo.path))
                        delete require.cache[key];
                });

                console.error(`[mods] ERROR: Module "${moduleInfo.name}" could not be loaded!`);
                console.error(`[mods] ERROR: Please contact the module's author: ${moduleInfo.supportUrl || DiscordURL}`);
                console.error(e);
            }
        }

        return module;
    }

    unload(name, logInfo = true) {
        const moduleInfo = this.getInfo(name);
        if (!moduleInfo) {
            console.error(`[mods] ERROR: Trying to load module that is not installed: ${name}`);
            return false;
        }

        let module = this.get(moduleInfo.name);
        if (!module) {
            console.error(`[mods] ERROR: Trying to unload module that is not loaded: ${moduleInfo.name}`);
            return false;
        }

        try {
            this.dispatch.unhookModule(moduleInfo.name);
            module.destructor();
            this.loadedModules.delete(moduleInfo.name);

            // Clear module files from require cache
            Object.keys(require.cache).forEach(key => {
                if (key.startsWith(moduleInfo.path))
                    delete require.cache[key];
            });

            if (logInfo)
                console.log(`[mods] Unloaded module "${moduleInfo.name}"`);
            return true;
        } catch (e) {
            console.error(`[mods] ERROR: Module "${moduleInfo.name}" could not be unloaded!`);
            console.error(`[mods] ERROR: Please contact the module's author: ${moduleInfo.supportUrl || DiscordURL}`);
            console.error(e);
            return false;
        }
    }

    reload(name, logInfo = true) {
        const moduleInfo = this.getInfo(name);
        if (!moduleInfo) {
            console.error(`[mods] ERROR: Trying to reload module that is not installed: ${name}`);
            return false;
        }
        if (!moduleInfo.options.reloadable) {
            console.error(`[mods] ERROR: Trying to reload module that does not support hot-reload: ${name}`);
            return false;
        }

        let module = this.get(moduleInfo.name);
        if (!module) {
            console.error(`[mods] ERROR: Trying to reload module that is not loaded: ${moduleInfo.name}`);
            return false;
        }

        const state = module.saveState();
        if (!this.unload(moduleInfo.name, false)) {
            console.error(`[mods] ERROR: Reload failed: ${moduleInfo.name}`);
            return false;
        }

        const newMod = this.load(name, false);
        if (!newMod) {
            console.error(`[mods] ERROR: Reload failed: ${moduleInfo.name}`);
            return false;
        }

        newMod.loadState(state);

        if (logInfo)
            console.log(`[mods] Reloaded module "${moduleInfo.name}"`);
        return true;
    }
}

module.exports = { listModules, loadModuleInfo, ModuleManager };
