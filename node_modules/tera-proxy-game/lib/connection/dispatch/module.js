"use strict";
const fs = require('fs');
const path = require('path');

class Module {
  constructor(dispatch, name, options) {
    this.dispatch = dispatch;
    this.options = options;
    this.name = name;
    this.niceName = options.niceName || name;
    this.rootFolder = options.rootFolder;

    // Module settings
    this.settingsVersion = options.settingsVersion || null;
    this.settingsFile = (this.settingsVersion === null) ? '' : path.join(this.rootFolder, options.settingsFile || 'module_settings.json');
    this.settingsMigrator = (this.settingsVersion === null) ? '' : path.join(this.rootFolder, options.settingsMigrator || 'module_settings_migrator.js');
    this.settingsAutosaveOnClose = (options.settingsAutosaveOnClose === undefined) ? true : options.settingsAutosaveOnClose;

    // Default modules
    this._command = null;
    this._game = null;

    // Timers
    this._timeouts = new Set();
    this._intervals = new Set();

    // Use tera-game-state callbacks to clear timers when entering/leaving the game
    if(this.game)
        this.game.on('leave_game', () => { this.clearAllTimeouts(); this.clearAllIntervals(); });

    this.loadSettings();
  }

  destructor() {
    if (this.settingsAutosaveOnClose)
      this.saveSettings();

    this._command = null;
    this._game = null;
  }

  load(name, from, required = true, options = {}, ...args) {
    const mod = this.dispatch.load(name, from, options, ...args);
    if (required && !mod) {
      throw new Error(`Cannot find module '${name}'`);
    }
    return mod;
  }

  unload(...args) {
    return this.dispatch.unload(...args);
  }

  hook(...args) {
    const hook = this.dispatch.hook(...args);
    hook.moduleName = this.name;
    return hook;
  }

  hookOnce(...args) {
    const cb = args.pop();
    if (typeof cb !== 'function') {
      throw new Error('last argument not a function');
    }

    const dispatch = this.dispatch,
          hook = dispatch.hook(...args, function() {
            dispatch.unhook(hook);
            return cb.apply(this, arguments);
          });

    return hook;
  }

  unhook(...args) {
    return this.dispatch.unhook(...args);
  }

  toClient(...args) {
    return this.dispatch.write(false, ...args);
  }

  toServer(...args) {
    return this.dispatch.write(true, ...args);
  }

  send(name, version, data) {
    if(typeof name !== 'string')
      throw Error('Raw send() is not supported');

    switch(name[0]) {
      case 'S':
      case 'I':
        return this.dispatch.write(false, name, version, data);
      case 'C':
        return this.dispatch.write(true, name, version, data);
      default:
        throw new Error(`Unknown packet direction: ${name}`);
    }
  }

  parseSystemMessage(...args) {
    return this.dispatch.parseSystemMessage(...args);
  }

  buildSystemMessage(...args) {
    return this.dispatch.buildSystemMessage(...args);
  }

  get moduleName() {
    // TODO: this will warn soon
    //console.log(`WARNING FOR DEVELOPERS: In ${this.name}: 'moduleName' is deprecated, use 'name' instead!`);
    return this.name;
  }

  get base() {
    // TODO: this will warn soon
    //console.log(`WARNING FOR DEVELOPERS: In ${this.name}: 'base' is deprecated and it is generally discouraged to directly access it! If absolutely necessary, use 'dispatch' instead!`);
    return this.dispatch;
  }

  get proxyAuthor() { return this.dispatch.proxyAuthor; }
  get region() { return this.dispatch.region; }
  get majorPatchVersion() { return this.dispatch.majorPatchVersion; }
  get minorPatchVersion() { return this.dispatch.minorPatchVersion; }
  get protocolVersion() { return this.dispatch.protocolVersion; }
  get isConsole() { return this.dispatch.isConsole(); }
  get isClassic() { return this.dispatch.isClassic(); }
  get platform() { return this.dispatch.platform; }
  get connection() { return this.dispatch.connection; }

  // Default modules
  get command() { if(this._command) return this._command; return (this._command = this.dispatch.get('command').createInstance(this)); }
  get game() { if(this._game) return this._game; return (this._game = this.dispatch.get('tera-game-state')); }

  // Module settings
  loadSettings() {
    if(this.settingsVersion === null)
      return;

    this.settings = {};

    let data = null;
    try {
      data = fs.readFileSync(this.settingsFile);
    } catch (_) {
      this.settings = this.migrateSettings(null, this.settingsVersion);
      return;
    }

    try {
      data = JSON.parse(data);
    } catch (e) {
      if(e.toString().includes('at position 0')) {
          console.error('WARNING: You closed proxy improperly the last time you were using it!');
          console.error(`WARNING: This caused the settings for module "${this.name}" to become corrupted!`);
          console.error('WARNING: The module will load default settings now, so adjust them according to your needs.');
          console.error('WARNING: Please remember to close proxy properly: first close the game, then close proxy using the X button!');
          console.error('WARNING: Do not shut down your computer while proxy is running!');

          this.settings = this.migrateSettings(null, this.settingsVersion);
          this.saveSettings();
          return;
      } else {
          console.error(`ERROR: Invalid settings format for module "${this.name}"!`);
          console.error('ERROR: This means that you broke it when manually editing it.');
          console.error('ERROR: Please fix the settings file manually or delete it so proxy can generate default settings for you.');
          console.error('------------------------------------------');
          console.error('Advanced error details');
          console.error('The full path to the file is:');
          console.error(`  ${this.settingsFile}`);
          console.error('The full error message is:');
          console.error(`  ${e}`);
          console.error('------------------------------------------');
          process.exit(1);
      }
    }

    if(this.settingsVersion !== data.version) {
      this.settings = this.migrateSettings(data.version, this.settingsVersion, (data.version !== undefined && data.data !== undefined) ? data.data : data);
      return;
    }

    this.settings = data.data;
  }

  saveSettings() {
    if(this.settingsVersion === null)
      return;

    let data = null;
    try {
      data = JSON.stringify({'version': this.settingsVersion, 'data': this.settings}, null, 4);

      try {
        fs.writeFileSync(this.settingsFile, data);
      } catch (e) {
        console.error(`ERROR: Unable to store settings for module ${this.name}! The full error message is:\nERROR: ${e}`);
      }
    } catch (e) {
      console.error(`ERROR: Unable to serialize settings for module ${this.name}! The full error message is:\nERROR: ${e}`);
    }
  }

  migrateSettings(from_ver, to_ver, settings) {
    try {
      let migrator = require(this.settingsMigrator);
      try {
        return migrator(from_ver, to_ver, settings);
      } catch (e) {
        console.error(`ERROR: An error occured while migrating the settings for module ${this.name}!\nERROR: The full error message is:\nERROR: ${e}`);
        process.exit(1);
      }
    } catch (e) {
      console.error(`ERROR: Unable to load settings migrator for module ${this.name}!\nERROR: The full error message is:\nERROR: ${e}`);
      process.exit(1);
    }
  }

  // Timers
  setTimeout(callback, delay, ...args) {
    const id = setTimeout(() => {
      callback(...args);
      this._timeouts.delete(id);
    }, delay);

    this._timeouts.add(id);
    return id;
  }

  clearTimeout(id) {
    if(this._timeouts.delete(id))
      clearTimeout(id);
  }

  clearAllTimeouts() {
    this._timeouts.forEach(clearTimeout);
    this._timeouts.clear();
  }

  get activeTimeouts() { return this._timeouts; }


  setInterval(callback, delay, ...args) {
    const id = setInterval(callback, delay, ...args);
    this._intervals.add(id);
    return id;
  }

  clearInterval(id) {
    if(this._intervals.delete(id))
      clearInterval(id);
  }

  clearAllIntervals() {
    this._intervals.forEach(clearInterval);
    this._intervals.clear();
  }

  get activeIntervals() { return this._intervals; }
}

module.exports = Module;
