const EventEmitter = require('events')
const path = require('path')
const util = require('util')
const Long = require('long')
const binarySearch = require('binary-search')
const { protocol, sysmsg } = require('tera-data-parser')
const types = Object.values(require('tera-data-parser').types)
const log = require('../../logger')
const Module = require('./module')

function* iterateHooks(globalHooks = [], codeHooks = []) {
	const globalHooksIterator = globalHooks[Symbol.iterator](); // .values()
	const codeHooksIterator = codeHooks[Symbol.iterator](); // .values()

	let nextGlobalHook = globalHooksIterator.next()
	let nextCodeHook = codeHooksIterator.next()

	while (!nextGlobalHook.done || !nextCodeHook.done) {
		const globalHookGroup = nextGlobalHook.value
		const codeHookGroup = nextCodeHook.value

		if(globalHookGroup && (!codeHookGroup || globalHookGroup.order <= codeHookGroup.order)) {
			yield* globalHookGroup.hooks
			nextGlobalHook = globalHooksIterator.next()
		} else {
			yield* codeHookGroup.hooks
			nextCodeHook = codeHooksIterator.next()
		}
	}
}

function getHookName(hook) {
	const callbackName = hook.callback ? (hook.callback.name || '(anonymous)') : '<unknown>'
	const moduleName = hook.moduleName || '<unknown>'
	return `${callbackName} in ${moduleName}`
}

function getMessageName(map, identifier, version, originalName) {
	if(typeof identifier === 'string') {
		const append = (identifier !== originalName) ? ` (original: "${originalName}")` : ''
		return `${identifier}<${version}>${append}`
	}

	if(typeof identifier === 'number') {
		const name = map.code.get(identifier) || `(opcode ${identifier})`
		return `${name}<${version}>`
	}

	return '(?)'
}

function parseStack(err) {
	const stack = (err && err.stack) || ''
	return stack.split('\n').slice(1).map((line) => {
		if(line.indexOf('(eval ') !== -1) {
			// throw away eval info
			// see <https://github.com/stacktracejs/error-stack-parser/blob/d9eb56a/error-stack-parser.js#L59>
			line = line.replace(/(\(eval at [^()]*)|(\),.*$)/g, '')
		}

		const match = line.match(/^\s*at (?:.+\s+\()?(?:(.+):\d+:\d+|([^)]+))\)?/)
		return match && {
			filename: match[2] || match[1],
			source: line,
		}
	}).filter(Boolean)
}

function errStack(err = new Error(), removeFront = true) {
	const stack = parseStack(err)
	const libPath = /tera-proxy-game[\\/]lib/

	// remove node internals from end
	while (stack.length > 0 && !path.isAbsolute(stack[stack.length - 1].filename)) {
		stack.pop()
	}

	// remove tera-proxy-game internals from end
	while (stack.length > 0 && libPath.test(stack[stack.length - 1].filename)) {
		stack.pop()
	}

	if(removeFront) {
		// remove tera-proxy-game internals from front
		while (stack.length > 0 && libPath.test(stack[0].filename)) {
			stack.shift()
		}
	}

	return stack.map(frame => frame.source).join('\n')
}

// -----------------------------------------------------------------------------

class Dispatch extends EventEmitter {
	constructor(connection, protocolVersion = 0) {
		super()

        this.proxyAuthor = 'caali'

		this.connection = connection
		this.modules = new Map()

		// hooks:
		// { <code>:
		//	 [ { <order>
		//		 , hooks:
		//			 [ { <code>, <filter>, <order>, <definitionVersion>, <moduleName>, <callback> }
		//			 ]
		//		 }
		//	 ]
		// }
		this.hooks = new Map()
		this.queuedHooks = []


		this.protocol = protocol.createInstance(this.isConsole() ? 'console' : (this.isClassic() ? 'classic' : 'pc'))
		this.protocol.load(require.resolve('tera-data'))

		this.latestDefVersion = new Map()
		if (this.protocol.messages) {
			for(const [name, defs] of this.protocol.messages) {
				this.latestDefVersion.set(name, Math.max(...defs.keys()))
			}
		}

		this.setProtocolVersion(protocolVersion)
	}

	reset() {
		for(const name of this.modules.keys()) {
			this.unload(name)
		}

		this.modules.clear()
		this.hooks.clear()
	}

	isConsole() {
		return !!this.connection.info.console;
	}

    isClassic() {
        return !!this.connection.info.classic;
    }

    get platform() {
        return this.isConsole() ? 'console' : (this.isClassic() ? 'classic' : 'pc');
    }

	parseSystemMessage(message) {
		if(message[0] !== '@') throw Error(`Invalid system message "${message}" (expected @)`)

		const tokens = message.split('\v'),
			id = tokens[0].substring(1),
			name = id.includes(':') ? id : this.sysmsgMap.code.get(parseInt(id))

		if(!name) throw Error(`Unmapped system message ${id} ("${message}")`)

		const data = {}

		for(let i = 2; i < tokens.length; i += 2) data[tokens[i - 1]] = tokens[i]

		return {id: name, tokens: data}
	}

	buildSystemMessage(message, data) {
		if(typeof message === 'string') message = {id: message, tokens: data}
		else {
			const type = message === null ? 'null' : typeof message

			if(type !== 'object') throw TypeError(`Expected object or string, got ${type}`)
			if(!message.id) throw Error('message.id is required')
		}

		const id = message.id.toString().includes(':') ? message.id : this.sysmsgMap.name.get(message.id)

		if(!id) throw Error(`Unknown system message "${message.id}"`)

		data = message.tokens

		let str = '@' + id

		for(let key in data) str += `\v${key}\v${data[key]}`

		return str
	}

    isLoaded(name) {
        return this.modules.has(name)
    }

    get(name) {
		const mod = this.modules.get(name)
        return mod ? mod.instance : null
    }

	load(name, from = module, options = {}, ...args) {
		const mod = this.modules.get(name)
		if(mod) return mod.instance

		if(typeof from.require !== 'function' && typeof from === 'function') {
			// `from` is a function, so use itself the module constructor
			from = { require: (ModuleConstructor => () => ModuleConstructor)(from) }
		}

		try {
			const ModuleConstructor = from.require(name)
			const mod = new Module(this, name, options)
			const loadedModule = new ModuleConstructor(mod, ...args)
			this.modules.set(name, {wrapper: mod, instance: loadedModule})

			log.info(`[dispatch] loaded "${name}"`)

			return loadedModule
		} catch (e) {
			log.error([
				`[dispatch] load: error initializing module "${name}"`,
				`error: ${e.message}`,
				errStack(e),
			].join('\n'))
		}

		return null
	}

	unload(name) {
		const mod = this.modules.get(name)

		if(!mod) {
			log.error([
				`[dispatch] unload: cannot unload non-loaded module "${name}"`,
				errStack(),
			].join('\n'))
			return false
		}

		for(const orderings of this.hooks.values()) {
			for(const ordering of orderings) {
				ordering.hooks = ordering.hooks.filter(hook => hook.moduleName !== name)
			}
		}

		if(typeof mod.instance.destructor === 'function') {
			try {
				mod.instance.destructor()
			} catch (e) {
				log.error([
					`[dispatch] unload: error running destructor for module instance "${name}"`,
					`error: ${e.message}`,
					errStack(e),
				].join('\n'))
			}
		}

		if(typeof mod.wrapper.destructor === 'function') {
			try {
				mod.wrapper.destructor()
			} catch (e) {
				log.error([
					`[dispatch] unload: error running destructor for module wrapper "${name}"`,
					`error: ${e.message}`,
					errStack(e),
				].join('\n'))
			}
		}

		this.modules.delete(name)
		return true
	}

	createHook(base, name, version, opts, cb) {
		// parse args
		if(typeof version !== 'number' && typeof version !== 'string')
            throw Error(`[dispatch] hook: version is required`)

		if(opts && typeof opts !== 'object') {
			cb = opts
			opts = {}
		}

		if(typeof cb !== 'function') {
			cb = () => {}

			log.error([
				`[dispatch] hook: last argument not a function (given: ${typeof cb})`,
				errStack(),
			].join('\n'))
		}

		// retrieve opcode
		let code
		if(name === '*') {
			code = name
			if(typeof version === 'number') {
				log.error([
					`[dispatch] hook: * hook must request version '*' or 'raw' (given: ${version})`,
					errStack(),
				]).join('\n')

				version = '*'
			}
		} else {
			code = this.protocolMap.name.get(name)
			if(code == null) {
				log.error([
					`[dispatch] hook: unrecognized hook target ${getMessageName(this.protocolMap, name, version, name)}`,
					errStack(),
				].join('\n'))

				code = '_UNKNOWN'
			}

			if(version !== '*') {
				const latest = this.latestDefVersion.get(name)
				if(latest && version < latest) {
					log.warn([
						`[dispatch] hook: ${getMessageName(this.protocolMap, name, version, name)} is not latest version (${latest})`,
						errStack(),
					].join('\n'))
				}
			}
		}

		// check version
		if(typeof version !== 'number') {
			if(version === 'latest') version = '*'
			if(version !== '*' && version !== 'raw') {
				// TODO warning
				version = '*'
			}
		}

		// check filters
		const filter = Object.assign({
			fake: false,
			incoming: null,
			modified: null,
			silenced: false,
		}, opts.filter)

		if(opts.type) {
			log.warn([
				'[dispatch] hook: "type" is deprecated; use "filter"',
				errStack(),
			].join('\n'))

			if(opts.type === 'all') filter.fake = null
			if(opts.type === 'fake') filter.fake = true
			if(opts.type === 'real') filter.fake = false
		}

		return Object.assign(base, {
			code,
			filter,
			order: opts.order || 0,
			definitionVersion: version,
			callback: cb,
			name: name || "",
		})
	}

	addHook(hook) {
		const { code, order } = hook

		if(!this.hooks.has(code)) {
			this.hooks.set(code, [])
		}

		const ordering = this.hooks.get(code)
		const index = binarySearch(ordering, { order }, (a, b) => a.order - b.order)
		if(index < 0) {
			// eslint-disable-next-line no-bitwise
			ordering.splice(~index, 0, { order, hooks: [hook] })
		} else {
			ordering[index].hooks.push(hook)
		}
	}

	hook(...args) {
		if(!this.protocolVersion) {
			const hook = {}
			this.queuedHooks.push({ hook, args })
			return hook
		}

		const hook = this.createHook({}, ...args)
		this.addHook(hook)
		return hook
	}

	unhook(hook) {
		if(!this.protocolVersion) {
			this.queuedHooks = this.queuedHooks.filter(h => h !== hook)
			return
		}

		if(!this.hooks.has(hook.code)) return

		const ordering = this.hooks.get(hook.code)
		const group = ordering.find(o => o.order === hook.order)
		if(group) group.hooks = group.hooks.filter(h => h !== hook)
	}

	write(outgoing, name, version, data) {
		if(!this.connection) return false

		if(Buffer.isBuffer(name)) {
			data = Buffer.from(name)
		} else {
			if(typeof version !== 'number' && typeof version !== 'string') {
				log.error(`[dispatch] write: version is required\n${errStack()}`)
				return false
			}

			if(version !== '*') {
				const latest = this.latestDefVersion.get(name)
				if(latest && version < latest) {
					log.warn([
						`[dispatch] write: ${getMessageName(this.protocolMap, name, version, name)} is not latest version (${latest})`,
						errStack(),
					].join('\n'))
				}
			}

			try {
				data = this.protocol.write(this.protocolVersion, name, version, data, null, null, null)
			} catch (e) {
				log.error([
					`[dispatch] write: failed to generate ${getMessageName(this.protocolMap, name, version, name)}`,
					`error: ${e.message}`,
					errStack(e, false)
				].join('\n'))
				return false
			}
		}

		data = this.handle(data, !outgoing, true)
		if(data === false) return false

		this.connection[outgoing ? 'sendServer' : 'sendClient'](data)
		return true
	}

	setProtocolVersion(version) {
		this.protocolVersion = version
        if (this.connection.info.protocol_data[this.protocolVersion]) {
            this.region = this.connection.info.protocol_data[this.protocolVersion].region
            this.majorPatchVersion = this.connection.info.protocol_data[this.protocolVersion].major_patch
            this.minorPatchVersion = this.connection.info.protocol_data[this.protocolVersion].minor_patch
        } else {
            if(this.protocolVersion !== 0) {
                log.error(`[dispatch] unrecognized protocol version ${this.protocolVersion}`)
                log.error('[dispatch] Unless a major game update was released within the past few hours, this means that')
                log.error('[dispatch] you are trying to play using an outdated client version!')
                log.error('[dispatch] Try a client repair or a reinstalling the game from scratch to fix this!')
            }
        }
		this.protocolMap = this.protocol.maps.get(this.protocolVersion)
		this.sysmsgMap = sysmsg.maps.get(this.protocolVersion);

		if(!this.protocolMap || !this.sysmsgMap) {
			if(this.protocolVersion !== 0) {
				log.error(`[dispatch] unmapped protocol version ${this.protocolVersion}`)
			}
		} else {
			log.info(`[dispatch] switching to protocol version ${this.protocolVersion}`)

			const hooks = this.queuedHooks
			this.queuedHooks = []
			for(const queued of hooks) {
				this.addHook(this.createHook(queued.hook, ...queued.args))
			}

			this.emit('init')
		}
	}

	handle(data, incoming, fake = false) {
		const code = data.readUInt16LE(2)

		if(code === 19900 && !this.protocolVersion) { // C_CHECK_VERSION
			// TODO hack; we should probably find a way to hardcode this, but it'll
			// work for now since this packet should never change (?)
			const ver = this.protocol.maps.keys().next().value

			try {
				const parsed = this.protocol.parse(ver, code, 1, data, null),
					[item] = parsed.version

				if(!item || item.index !== 0) {
					log.error([
						'[dispatch] handle: failed to retrieve protocol version from C_CHECK_VERSION<1> (index != 0)',
						`data: ${data.toString('hex')}`,
						`item: ${JSON.stringify(item)}`,
					].join('\n'))
				} else {
					this.setProtocolVersion(item.value)
				}
			}
			catch(e) {
				log.error([
					'[dispatch] handle: failed to parse C_CHECK_VERSION<1> for dynamic protocol versioning',
					`data: ${data.toString('hex')}`,
					`error: ${e.message}`,
					errStack(e),
				].join('\n'))
			}
		}

		const copy = Buffer.from(data)

		const globalHooks = this.hooks.get('*')
		const codeHooks = this.hooks.get(code)
		if(!globalHooks && !codeHooks) return data

		const { protocolVersion } = this
		let modified = false
		let silenced = false

		function bufferAttachFlags(buf) {
			Object.defineProperties(buf, {
				$fake: { get: () => fake },
				$incoming: { get: () => incoming },
				$modified: { get: () => modified },
				$silenced: { get: () => silenced },
			})
		}

		function objectAttachFlags(obj) {
			Object.defineProperties(obj, {
				$fake: { value: fake },
				$incoming: { value: incoming },
				$modified: { value: modified },
				$silenced: { value: silenced },
			})
		}

		bufferAttachFlags(data)

		let eventCache = [],
			iter = 0,
			hooks = (globalHooks ? globalHooks.size : 0) + (codeHooks ? codeHooks.size : 0)

		for(const hook of iterateHooks(globalHooks, codeHooks)) {
			// check flags
			const { filter } = hook
			if(filter.fake != null && filter.fake !== fake) continue
			if(filter.incoming != null && filter.incoming !== incoming) continue
			if(filter.modified != null && filter.modified !== modified) continue
			if(filter.silenced != null && filter.silenced !== silenced) continue

			const lastHook = ++iter === hooks

			if(hook.definitionVersion === 'raw')
				try {
					const result = hook.callback(code, data, incoming, fake)

					if(Buffer.isBuffer(result) && result !== data) {
						modified = modified || (result.length !== data.length) || !result.equals(data)
						bufferAttachFlags(result)
						data = result
					} else {
						modified = modified || !data.equals(copy)
						if(typeof result === 'boolean') silenced = !result
					}
				}
				catch(e) {
					log.error([
						`[dispatch] handle: error running raw hook for ${getMessageName(this.protocolMap, code, hook.definitionVersion)}`,
						`hook: ${getHookName(hook)}`,
						`data: ${data.toString('hex')}`,
						`error: ${e.message}`,
						errStack(e),
					].join('\n'))
					continue
				}
			else { // normal hook
				try {
					const defVersion = hook.definitionVersion

					let event = eventCache[defVersion] || (eventCache[defVersion] = this.protocol.parse(protocolVersion, code, defVersion, data, null))

					objectAttachFlags(lastHook ? event : (event = deepClone(event)))

					try {
						const result = hook.callback(event, fake)

						if(result === true) {
							modified = true
							silenced = false

							try {
								data = this.protocol.write(protocolVersion, code, defVersion, event, null, null, null)
								bufferAttachFlags(data)

								eventCache = []
							} catch (e) {
								log.error([
									`[dispatch] handle: failed to generate ${getMessageName(this.protocolMap, code, defVersion)}`,
									`hook: ${getHookName(hook)}`,
									`error: ${e.message}`,
									errStack(e, false),
								].join('\n'))
							}
						}
						else if(result === false) silenced = true
					}
					catch(e) {
						log.error([
							`[dispatch] handle: error running hook for ${getMessageName(this.protocolMap, code, defVersion)}`,
							`hook: ${getHookName(hook)}`,
							`data: ${util.inspect(event)}`,
							`error: ${e.message}`,
							errStack(e),
						].join('\n'))
					}
				}
				catch(e) {
					log.error([
						`[dispatch] handle: failed to parse ${getMessageName(this.protocolMap, code, hook.definitionVersion)}`,
						`hook: ${getHookName(hook)}`,
						`data: ${data.toString('hex')}`,
						`error: ${e.message}`,
						errStack(e, false),
					].join('\n'))
				}
			}
		}

		// return value
		return (!silenced ? data : false)
	}
}

function deepClone(obj) {
	if(obj instanceof Long) return new Long(obj.low, obj.high, obj.unsigned)
	if(obj instanceof Buffer) return new Buffer.from(obj)

	for(let t of types) // Custom parser types
		if(obj instanceof t) return Object.assign(Object.create(t.prototype), obj)

	let copy = Array.isArray(obj) ? [] : {}

	for(let key in obj) {
		let val = obj[key]

		if(typeof val === 'object') copy[key] = deepClone(val)
		else copy[key] = val
	}

	return copy
}

module.exports = Dispatch
